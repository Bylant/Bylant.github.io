
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>苍穹盛夏的博客</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="如何在面试中介绍自己的项目经验
在面试时，经过寒暄后，一般面试官会让介绍项目经验 。常见的问法是，说下你最近的（或最拿得出手的）一个项目。根据我们的面试经验，发现有不少候选人对此没准备，说起来磕磕巴,"> 
    <meta name="author" content="zhoudl"> 
    <link rel="alternative" href="atom.xml" title="苍穹盛夏的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">Quartz原理解密</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">Quartz原理解密</h1>
        <div class="stuff">
            <span>一月 29, 2019</span>
            

        </div>
        <div class="content markdown">
            <h1 id="Quartz原理解密"><a href="#Quartz原理解密" class="headerlink" title="Quartz原理解密"></a>Quartz原理解密</h1><blockquote>
<p>Author: Dorae<br>原文链接：<a href="https://juejin.im/post/5c3bf24951882523d3201c54?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5c3bf24951882523d3201c54?utm_source=gold_browser_extension</a></p>
</blockquote>
<h2 id="一、quartz概述"><a href="#一、quartz概述" class="headerlink" title="一、quartz概述"></a>一、quartz概述</h2><p>quartz是一个用java实现的开源任务调度框架，可以用来创建简单或者复杂的任务调度，并且可以提供许多企业级的功能，比如JTA以及集群等，是当今比较流行的JAVA任务调度框架。</p>
<h3 id="1-可以用来做什么"><a href="#1-可以用来做什么" class="headerlink" title="1. 可以用来做什么"></a>1. 可以用来做什么</h3><p>Quartz是一个任务调度框架，当遇到以下问题时：</p>
<ul>
<li>想在每月25号，自动还款；</li>
<li>想在每年4月1日给当年自己暗恋的女神发一封匿名贺卡；</li>
<li>想每隔1小时，备份一下自己的各种资料。</li>
</ul>
<p>那么总结起来就是，在一个有规律的时间点做一些事情，并且这个规律可以非常复杂，复杂到了需要一个框架来帮助我们。Quartz的出现就是为了解决这个问题，定义一个触发条件，那么其负责到了特定的时间点，触发相应的job干活。</p>
<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h3><ul>
<li>强大的调度功能，例如丰富多样的调度方法，可以满足各种常规和特殊需求；</li>
<li>灵活的应用方式，比如支持任务调度和任务的多种组合，支持数据的多种存储（DB，RAM等；</li>
<li>支持分布式集群，在被Terracotta收购之后，在原来基础上进行了进一步的改造。</li>
</ul>
<h2 id="二、quartz基本原理"><a href="#二、quartz基本原理" class="headerlink" title="二、quartz基本原理"></a>二、quartz基本原理</h2><h3 id="1-核心元素"><a href="#1-核心元素" class="headerlink" title="1. 核心元素"></a>1. 核心元素</h3><p>Quartz核心要素有Scheduler、Trigger、Job、JobDetail，其中trigger和job、jobDetail为元数据，而Scheduler为实际进行调度的控制器。</p>
<ul>
<li>Trigger</li>
</ul>
<p>Trigger用于定义调度任务的时间规则，在Quartz中主要有四种类型的Trigger：SimpleTrigger、CronTrigger、DataIntervalTrigger和NthIncludedTrigger。</p>
<ul>
<li>Job&amp;Jodetail</li>
</ul>
<p>Quartz将任务分为Job、JobDetail两部分，其中Job用来定义任务的执行逻辑，而JobDetail用来描述Job的定义（例如Job接口的实现类以及其他相关的静态信息）。对Quartz而言，主要有两种类型的Job，StateLessJob、StateFulJob</p>
<ul>
<li>Scheduler</li>
</ul>
<p>实际执行调度逻辑的控制器，Quartz提供了DirectSchedulerFactory和StdSchedulerFactory等工厂类，用于支持Scheduler相关对象的产生。</p>
<h3 id="2-核心元素间关系"><a href="#2-核心元素间关系" class="headerlink" title="2. 核心元素间关系"></a>2. 核心元素间关系</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/14/1684a2a64cd7144c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="3-主要线程"><a href="#3-主要线程" class="headerlink" title="3. 主要线程"></a>3. 主要线程</h3><p>在Quartz中，有两类线程，也即执行线程和调度线程，其中执行任务的线程通常用一个线程池维护。线程间关系如图所示。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/14/1684a2a64b28e2da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>在quartz中，Scheduler调度线程主要有两个：regular Scheduler Thread（执行常规调度）和Misfire Scheduler Thread（执行错失的任务）。其中Regular Thread 轮询Trigger，如果有将要触发的Trigger，则从任务线程池中获取一个空闲线程，然后执行与改Trigger关联的job；Misfire Thraed则是扫描所有的trigger，查看是否有错失的，如果有的话，根据一定的策略进行处理。</p>
<h3 id="4-数据存储"><a href="#4-数据存储" class="headerlink" title="4. 数据存储"></a>4. 数据存储</h3><p>Quartz中的trigger和job需要存储下来才能被使用。Quartz中有两种存储方式：RAMJobStore,JobStoreSupport，其中RAMJobStore是将trigger和job存储在内存中，而JobStoreSupport是基于jdbc将trigger和job存储到数据库中。RAMJobStore的存取速度非常快，但是由于其在系统被停止后所有的数据都会丢失，所以在集群应用中，必须使用JobStoreSupport。其中表结构如表所示。</p>
<table>
<thead>
<tr>
<th>Table name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>QRTZ_CALENDARS</td>
<td>存储Quartz的Calendar信息</td>
</tr>
<tr>
<td>QRTZ_CRON_TRIGGERS</td>
<td>存储CronTrigger，包括Cron表达式和时区信息</td>
</tr>
<tr>
<td>QRTZ_FIRED_TRIGGERS</td>
<td>存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息</td>
</tr>
<tr>
<td>QRTZ_PAUSED_TRIGGER_GRPS</td>
<td>存储已暂停的Trigger组的信息</td>
</tr>
<tr>
<td>QRTZ_SCHEDULER_STATE</td>
<td>存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td>
</tr>
<tr>
<td>QRTZ_LOCKS</td>
<td>存储程序的悲观锁的信息</td>
</tr>
<tr>
<td>QRTZ_JOB_DETAILS</td>
<td>存储每一个已配置的Job的详细信息</td>
</tr>
<tr>
<td>QRTZ_SIMPLE_TRIGGERS</td>
<td>存储简单的Trigger，包括重复次数、间隔、以及已触的次数</td>
</tr>
<tr>
<td>QRTZ_BLOG_TRIGGERS</td>
<td>Trigger作为Blob类型存储</td>
</tr>
<tr>
<td>QRTZ_TRIGGERS</td>
<td>存储已配置的Trigger的信息</td>
</tr>
<tr>
<td>QRTZ_SIMPROP_TRIGGERS</td>
</tr>
</tbody>
</table>
<h2 id="三、quartz集群原理"><a href="#三、quartz集群原理" class="headerlink" title="三、quartz集群原理"></a>三、quartz集群原理</h2><p>一个Quartz集群中的每个节点是一个独立的Quartz应用，它又管理着其他的节点。这就意味着你必须对每个节点分别启动或停止。Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的，如图所示。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/14/1684a2a64b5a2943?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="四、quartz主要流程"><a href="#四、quartz主要流程" class="headerlink" title="四、quartz主要流程"></a>四、quartz主要流程</h2><h3 id="1-启动流程"><a href="#1-启动流程" class="headerlink" title="1. 启动流程"></a>1. 启动流程</h3><p>若quartz是配置在spring中，当服务器启动时，就会装载相关的bean。SchedulerFactoryBean实现了InitializingBean接口，因此在初始化bean的时候，会执行afterPropertiesSet方法，该方法将会调用SchedulerFactory(DirectSchedulerFactory 或者 StdSchedulerFactory，通常用StdSchedulerFactory)创建Scheduler。SchedulerFactory在创建quartzScheduler的过程中，将会读取配置参数，初始化各个组件，关键组件如下：</p>
<ol>
<li><p><strong>ThreadPool</strong>:一般是使用SimpleThreadPool,SimpleThreadPool创建了一定数量的WorkerThread实例来使得Job能够在线程中进行处理。WorkerThread是定义在SimpleThreadPool类中的内部类，它实质上就是一个线程。在SimpleThreadPool中有三个list：workers-存放池中所有的线程引用，availWorkers-存放所有空闲的线程，busyWorkers-存放所有工作中的线程； 线程池的配置参数如下所示：</p>
<p>org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPool org.quartz.threadPool.threadCount=3 org.quartz.threadPool.threadPriority=5</p>
</li>
<li><p><strong>JobStore</strong>:分为存储在内存的RAMJobStore和存储在数据库的JobStoreSupport(包括JobStoreTX和JobStoreCMT两种实现，JobStoreCMT是依赖于容器来进行事务的管理，而JobStoreTX是自己管理事务），若要使用集群要使用JobStoreSupport的方式；</p>
</li>
<li><p><strong>QuartzSchedulerThread</strong>:用来进行任务调度的线程，在初始化的时候paused=true,halted=false,虽然线程开始运行了，但是paused=true，线程会一直等待，直到start方法将paused置为false；</p>
</li>
</ol>
<p>另外，SchedulerFactoryBean还实现了SmartLifeCycle接口，因此初始化完成后，会执行start()方法，该方法将主要会执行以下的几个动作：</p>
<ol>
<li>创建ClusterManager线程并启动线程:该线程用来进行集群故障检测和处理，将在下文详细讨论；</li>
<li>创建MisfireHandler线程并启动线程:该线程用来进行misfire任务的处理，将在下文详细讨论；</li>
<li>置QuartzSchedulerThread的paused=false，调度线程才真正开始调度；</li>
</ol>
<p>Quartz的整个启动流程如图所示。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/14/1684a2a64b6a1c91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="2-QuartzSchedulerThread线程"><a href="#2-QuartzSchedulerThread线程" class="headerlink" title="2. QuartzSchedulerThread线程"></a>2. QuartzSchedulerThread线程</h3><p>QuartzSchedulerThread线程是实际执行任务调度的线程，其中主要代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!halted.get()) &#123;</span><br><span class="line">	<span class="keyword">int</span> availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();</span><br><span class="line">	triggers = qsRsrcs.getJobStore().acquireNextTriggers(now + idleWaitTime,</span><br><span class="line">			Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());</span><br><span class="line">	<span class="keyword">long</span> triggerTime = triggers.get(<span class="number">0</span>).getNextFireTime().getTime();</span><br><span class="line">	<span class="keyword">long</span> timeUntilTrigger = triggerTime - now;</span><br><span class="line">	<span class="keyword">while</span> (timeUntilTrigger &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		now = System.currentTimeMillis();</span><br><span class="line">		timeUntilTrigger = triggerTime - now;</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;TriggerFiredResult&gt; bndle = qsRsrcs.getJobStore().triggersFired(triggers);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">		JobRunShell shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);</span><br><span class="line">		shell.initialize(qs);</span><br><span class="line">		qsRsrcs.getThreadPool().runInThread(shell);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先获取线程池中的可用线程数量（若没有可用的会阻塞，直到有可用的）；</li>
<li>获取30m内要执行的trigger(即acquireNextTriggers)： 获取trigger的锁，通过select …for update方式实现；获取30m内（可配置）要执行的triggers（需要保证集群节点的时间一致），若@ConcurrentExectionDisallowed且列表存在该条trigger则跳过，否则更新trigger状态为ACQUIRED(刚开始为WAITING)；插入firedTrigger表，状态为ACQUIRED;（注意：在RAMJobStore中，有个timeTriggers，排序方式是按触发时间nextFireTime排的；JobStoreSupport从数据库取出triggers时是按照nextFireTime排序）;</li>
<li>等待直到获取的trigger中最先执行的trigger在2ms内；</li>
<li>triggersFired：<ol>
<li>更新firedTrigger的status=EXECUTING;</li>
<li>更新trigger下一次触发的时间；</li>
<li>更新trigger的状态：无状态的trigger-&gt;WAITING，有状态的trigger-&gt;BLOCKED，若nextFireTime==null -&gt;COMPLETE；</li>
<li>commit connection,释放锁；</li>
</ol>
</li>
<li>针对每个要执行的trigger，创建JobRunShell，并放入线程池执行：<ol>
<li>execute:执行job</li>
<li>获取TRIGGER_ACCESS锁</li>
<li>若是有状态的job：更新trigger状态：BLOCKED-&gt;WAITING,PAUSED_BLOCKED-&gt;BLOCKED</li>
<li>若@PersistJobDataAfterExecution，则updateJobData</li>
<li>删除firedTrigger</li>
<li>commit connection，释放锁</li>
</ol>
</li>
</ol>
<p>调度线程的执行流程如图所示。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/14/1684a2a64b434d22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>调度过程中Trigger状态变化如图所示。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/14/1684a2a64cff820c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="3-MisfireHandler线程"><a href="#3-MisfireHandler线程" class="headerlink" title="3. MisfireHandler线程"></a>3. MisfireHandler线程</h3><p>下面这些原因可能造成 misfired job:</p>
<ol>
<li>系统因为某些原因被重启。在系统关闭到重新启动之间的一段时间里，可能有些任务会被 misfire；</li>
<li>Trigger 被暂停（suspend）的一段时间里，有些任务可能会被 misfire；</li>
<li>线程池中所有线程都被占用，导致任务无法被触发执行，造成 misfire；</li>
<li>有状态任务在下次触发时间到达时，上次执行还没有结束；为了处理 misfired job，Quartz 中为 trigger 定义了处理策略，主要有下面两种：<ul>
<li>MISFIRE_INSTRUCTION_FIRE_ONCE_NOW：针对 misfired job 马上执行一次；</li>
<li>MISFIRE_INSTRUCTION_DO_NOTHING：忽略 misfired job，等待下次触发；默认是MISFIRE_INSTRUCTION_SMART_POLICY，该策略在CronTrigger中=MISFIRE_INSTRUCTION_FIRE_ONCE_NOW线程默认1分钟执行一次；在一个事务中，默认一次最多recovery 20个；</li>
</ul>
</li>
</ol>
<p>执行流程：</p>
<ol>
<li>若配置(默认为true，可配置)成获取锁前先检查是否有需要recovery的trigger，先获取misfireCount；</li>
<li>获取TRIGGER_ACCESS锁；</li>
<li>hasMisfiredTriggersInState：获取misfired的trigger，默认一个事务里只能最大20个misfired trigger（可配置），misfired判断依据：status=waiting,next_fire_time &lt; current_time-misfirethreshold(可配置，默认1min)</li>
<li>notifyTriggerListenersMisfired</li>
<li>updateAfterMisfire:获取misfire策略(默认是MISFIRE_INSTRUCTION_SMART_POLICY，该策略在CronTrigger中=MISFIRE_INSTRUCTION_FIRE_ONCE_NOW)，根据策略更新nextFireTime；</li>
<li>将nextFireTime等更新到trigger表；</li>
<li>commit connection，释放锁8.如果还有更多的misfired，sleep短暂时间(为了集群负载均衡)，否则sleep misfirethreshold时间，后继续轮询；</li>
</ol>
<p>misfireHandler线程执行流程如图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/14/1684a2a66aa45772?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="4-ClusterManager集群管理线程"><a href="#4-ClusterManager集群管理线程" class="headerlink" title="4. ClusterManager集群管理线程"></a>4. ClusterManager集群管理线程</h3><p>初始化：</p>
<p>failedInstance=failed+self+firedTrigger表中的schedulerName在scheduler_state表中找不到的（孤儿）</p>
<p>线程执行：</p>
<p>每个服务器会定时(org.quartz.jobStore.clusterCheckinInterval这个时间)更新SCHEDULER_STATE表的LAST_CHECKIN_TIME，若这个字段远远超出了该更新的时间，则认为该服务器实例挂了；</p>
<p>注意：每个服务器实例有唯一的id，若配置为AUTO，则为hostname+current_time</p>
<p>线程执行的具体流程：</p>
<ol>
<li>检查是否有超时的实例failedInstances;</li>
<li>更新该服务器实例的LAST_CHECKIN_TIME； 若有超时的实例：</li>
<li>获取STATE_ACCESS锁；</li>
<li>获取超时的实例failedInstances;</li>
<li>获取TRIGGER_ACCESS锁；</li>
<li>clusterRecover:<ul>
<li>针对每个failedInstances，通过instanceId获取每个实例的firedTriggers;</li>
<li>针对每个firedTrigger：<ul>
<li>更新trigger状态：<ul>
<li>BLOCKED-&gt;WAITING</li>
<li>PAUSED_BLOCKED-&gt;PAUSED</li>
<li>ACQUIRED-&gt;WAITING</li>
</ul>
</li>
<li>若firedTrigger不是ACQUIRED状态（在执行状态）,且jobRequestRecovery=true: 创建一个SimpleTrigger，存储到trigger表，status=waiting,MISFIRE_INSTR=MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY.</li>
<li>删除firedTrigger</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>clusterManager线程执行时序图如图1-8所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/14/1684a2a66eee57d6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="五、注意问题"><a href="#五、注意问题" class="headerlink" title="五、注意问题"></a>五、注意问题</h2><ol>
<li><strong>时间同步问题</strong></li>
</ol>
<p>Quartz实际并不关心你是在相同还是不同的机器上运行节点。当集群放置在不同的机器上时，称之为水平集群。节点跑在同一台机器上时，称之为垂直集群。对于垂直集群，存在着单点故障的问题。这对高可用性的应用来说是无法接受的，因为一旦机器崩溃了，所有的节点也就被终止了。对于水平集群，存在着时间同步问题。</p>
<p>节点用时间戳来通知其他实例它自己的最后检入时间。假如节点的时钟被设置为将来的时间，那么运行中的Scheduler将再也意识不到那个结点已经宕掉了。另一方面，如果某个节点的时钟被设置为过去的时间，也许另一节点就会认定那个节点已宕掉并试图接过它的Job重运行。最简单的同步计算机时钟的方式是使用某一个Internet时间服务器(Internet Time Server ITS)。</p>
<ol>
<li><strong>节点争抢Job问题</strong></li>
</ol>
<p>因为Quartz使用了一个随机的负载均衡算法，Job以随机的方式由不同的实例执行。Quartz官网上提到当前，还不存在一个方法来指派(钉住) 一个 Job 到集群中特定的节点。</p>
<ol>
<li><strong>从集群获取Job列表问题</strong></li>
</ol>
<p>当前，如果不直接进到数据库查询的话，还没有一个简单的方式来得到集群中所有正在执行的Job列表。请求一个Scheduler实例，将只能得到在那个实例上正运行Job的列表。Quartz官网建议可以通过写一些访问数据库JDBC代码来从相应的表中获取全部的Job信息。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li>
                    
                        <li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Quartz原理解密"><span class="toc-number">1.</span> <span class="toc-text">Quartz原理解密</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、quartz概述"><span class="toc-number">1.1.</span> <span class="toc-text">一、quartz概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-可以用来做什么"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 可以用来做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-特点"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、quartz基本原理"><span class="toc-number">1.2.</span> <span class="toc-text">二、quartz基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-核心元素"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 核心元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-核心元素间关系"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 核心元素间关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-主要线程"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 主要线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-数据存储"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 数据存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、quartz集群原理"><span class="toc-number">1.3.</span> <span class="toc-text">三、quartz集群原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、quartz主要流程"><span class="toc-number">1.4.</span> <span class="toc-text">四、quartz主要流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-启动流程"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-QuartzSchedulerThread线程"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. QuartzSchedulerThread线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MisfireHandler线程"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. MisfireHandler线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ClusterManager集群管理线程"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. ClusterManager集群管理线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、注意问题"><span class="toc-number">1.5.</span> <span class="toc-text">五、注意问题</span></a></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>